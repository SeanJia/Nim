__author__ = 'Zhiwei Jia'import random as rdimport numpy as npimport sysclass Nim:    """ a class representing the game Nim, with algorithm implemented by Zhiwei Jia based on        relevant Combinatorial Game Theory    """    def __init__(self):  # initialize a Nim game with a random stone list        self.stone_list = np.array([1,2,3,4,5])        self.win = False        self.restart = False        self.quit = False    def fight(self):    # computer's move with designed strategy        self.mat = to_binary_matrix(self.stone_list)        self.parity = test_parity(self.mat)        if restore_even(self.parity, self.mat, self.stone_list):            pass        else:            remove_one(self.stone_list)            print(to_binary_matrix(self.stone_list))    def one_game(self): # a single game        self.stone_list = get_random_list()        self.prompt_for_order()        if self.user_first:            self.user_move()            print('After your move:', self.stone_list)        while True:            if is_gameover(self.stone_list.tolist()):                break            self.fight()            print('After my move:', self.stone_list)            if is_gameover(self.stone_list.tolist()):                cont = False                self.win = True                break            if self.user_move():                print('After your move:', self.stone_list)            else:                print('You choose to restart...\n')                cont = False                self.restart = True                return        if self.win:            print('Sorry, I win.')        else:            print('Congratulations! You win! Type any key to continue for another game.' +                   ' Or type \'q\' to quit')            res = sys.stdin.readline()            if res == 'q\n':                self.quit = True    def play(self):   # the continuous game        while True:            self.one_game()            if self.restart:                pass            if self.quit:                break        print('Thank you. See you next time!')    def prompt_for_order(self): # prompt for user to specify who is the first player        print(self.stone_list, '\nFor this randomized 5 piles of stones,' +              ' do you want to be the first player? (type \'yes\' if so, by default is no)')        response = sys.stdin.readline()        if response == 'yes\n':            self.user_first = True        else:            self.user_first = False    def user_move(self):       # a user's move        while True:            print('Enter your move, e.g., \'3-1\' means remove one stone from the third pile.\n' +                   'Or you can enter \'restart\' to restart a new game (unavailable for the first move)')            instr = sys.stdin.readline()            if instr == 'restart\n':                return False            if len(instr) < 4:                print('Invalid Input.')                continue            else:                a, b, c = instr[0], instr[1], instr[2]                if not a.isdigit() or not c.isdigit() or int(a)-1 not in range(5) or b != '-' or \                        self.stone_list[int(a)-1] - int(c) < 0 or int(c) < 1:                    print('Invalid Input.')                    continue            self.stone_list[int(a)-1] -= int(c)            break        return Truedef get_random_list():  # to get a random list representing five piles of stones    return np.array([rd.randrange(9)+1 for x in range(5)])def to_binary_matrix(list): # to convert the stone list into a binary matrix    mat = np.array([[int(char) for char in to_bin(list[0])],                    [int(char) for char in to_bin(list[1])],                    [int(char) for char in to_bin(list[2])],                    [int(char) for char in to_bin(list[3])],                    [int(char) for char in to_bin(list[4])]])    return matdef to_bin(x):  # to convert a base 10 number string to a 4-width binary string    return (bin(x)[2:]).zfill(4)def test_parity(mat): # find out the four parities in this game    pow_3 = mat[0][0]^mat[1][0]^mat[2][0]^mat[3][0]^mat[4][0]    pow_2 = mat[0][1]^mat[1][1]^mat[2][1]^mat[3][1]^mat[4][1]    pow_1 = mat[0][2]^mat[1][2]^mat[2][2]^mat[3][2]^mat[4][2]    pow_0 = mat[0][3]^mat[1][3]^mat[2][3]^mat[3][3]^mat[4][3]    return np.array([pow_3, pow_2, pow_1, pow_0])def test_even(parity): # test whether all parities are even    return parity[0] or parity[1] or parity[2] or parity[3]def restore_even(parity, mat, list): # to restore the evenness for all parities    first_odd, take_from, take_pile, add_to = -1, [], -1, []    if test_even(parity) != 0:        for i in range(4):            if parity[i] == 1:                first_odd = i                break        take_pile = rd.choice([j for j in range(5) if mat[j][first_odd] == 1])        take_from.append(first_odd)        for i in range(first_odd+1, 4):            if parity[i] == 1:                if mat[take_pile][i] == 1:                    take_from.append(i)                else:                    add_to.append(i)            else:                pass        for i in take_from:            mat[take_pile][i] = 0            list[take_pile] -= 2**(3-i)        for i in add_to:            mat[take_pile][i] = 1            list[take_pile] += 2**(3-i)        return True    else:        return Falsedef remove_one(list): # randomly remove one stone from the stone list    list[rd.choice([i for i in range(5) if list[i] > 0])] -= 1def is_gameover(list): # test whether the stone list is empty, i.e., game is over    for i in list:        if i > 0:            return False    return True# start the game and enjoy!game = Nim()game.play()